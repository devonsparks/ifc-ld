= IFC-LD
v0.1, October, 2022: Pre-Release Draft 1
:sectnums:
:figure-caption!:
:toc:


== Rationale

IFC-LD is a data model and family of serializations designed to support the exchange of information about the built environment. It provides a standard set of pre-defined "Containers" - Packages, Objects, and Slots - in which stakeholders can store and exchange information. It is interoperable with all existing versions of IFC, while supporting integration with alternative data models through use of linked data. Practically, IFC-LD aims to replace ISO 130301 Part 21 ("STEP" files) as the defacto exchange format for IFC. 

IFC-LD attempts to solve several problems with IFC-based data exchanges through use of convention:

1. To avoid use of custom parsers for ISO 130301 P21 ("STEP") files, IFC-LD provides a standard set of JSON-based serializations.

2. To support integration and linking of data, IFC-LD uses JSON-LD to make the JSON serializations double as linked data.

3. To discourage the use of monolithic model files, IFC-LD makes all assets (down to individual properties or "slots") uniformly addressable, and provides well-defined ways to share them with stakeholders.

IFC-LD standardizes the ways IFC and IFC-adjacent data is packaged, but delegates to other specifications what those packages should contain for a particular use case. This separation of structure of the data envelope (IFC-LD) from the structure of its contents is what allows IFC-LD to integrate all existing IFC schemas while supporting new directions.

== Requirements

=== Data Addressability
All exchanged data must be unformly addressable, because linking or referencing data requires it have a name. Given the distributed, global nature of the built environment, the most natural namespace for built assets is the web, where shared assets are addressable by URIs. 

=== Interoperability (with STEP)
The vast majority of the world's existing IFC data is encoded as ISO 13031 Part 21 STEP files. It is also the primary serialization existing commercial systems support. To encourage broad adoption of IFC-LD, and to ensure we can migrate existing asset data, interoperability with the Part 21 exchange format is required.

=== Distributed By Design
The data describing built assets is inherently distributed, because stakeholders describe assets from different points of view at different points in time. Any forward-looking exchange strategy, including IFC-LD, must take widespread data distribution and composition as prerequisites.

=== Extensibility
The IFC-LD specification cannot anticipate every need. Instead, it must provide a small set of capabilities that could later be extended. Rather than inventing these extension capabilities from scratch, it can reuse those provided by the modeling layers it builds upon (i.e., RDFS).

== Design

=== Data Model

IFC-LD models a standard set of data "containers". Each container type and its relations are specified within RDFS, a data-modeling vocaulary for linked data. Through the use of JSON-LD, users of IFC-LD can produce and consume valid IFC-LD without any knowledge of linked data, treating it only as JSON following a standard JSON Schema.  

IFC-LD defines the following container types for organizing information:

==== Container
"Container" is the root element within the IFC-LD type hierarchy. All assets exchanged via IFC-LD are derived from Container. Containers defines several key properties: 

* *@id*: Required. Defines the URI address of the IFC-LD Container
* *@type*: Required. Defines one or more sets (also identified by URIs) with which this Container shares a common trait (e.g., "ifc4:person" is the @type of all IFC4 Person instances)
* *group*: Optional. A set of strings tagging the Container under a common functional category (e.g., "Energy Performance", "Design Phase", "Unverified")


==== Slots

A Slot is a Container that holds "contents", captured at a specific time, declared by a specific stakeholder. A Slot's "contents" can represent a property value, a reference to an Object, or some other capability defined by other specifications. 

Here are example Slots in IFC-LD:

NB: "contents":{"@container":"@list", "@id":"http://ifc-ld.org#contents"},

```
{   "@id":"Bdskjasd/asdj"
    "@type":["Slot", "ifc4:person/4"],
    "slotof":"Bdskjasd",
    "contents":[{
        "@type":"xsd:string",
        "value":".METRIC."
    }]
}

{   "@id":"Bdskjasd/asdj"
    "@type":["Slot", "ifc4:person/4"],
    "slotof":"Bdskjasd",
    "contents":[
         {
           "@type":"xsd:string",
           "value":".METRIC."
           }
        ]
}

{   "@id":"Bdskjasd/asdj"
    "@type":["Slot", "ifc4:person/4"],
    "slotof":"Bdskjasd",
    "contents":[{
        "@id":"fooo"
}]
```

Slots _should_ be related to the Objects they qualify through the "slotof" property. A Slot may be the _slotof_ more than one Object. When seen from the point of view of an Object, Slots describe qualifying aspects of that Object.

Slot data is stored in its "contents". The structure of _contents_ depends on the Slot. For Object references, contents provides the @id of the targeted Object. For property values, "contents" is made up of a "@type" and  "value". Composite values (lists, sets) is made up of @type and "values" (an array), represented as a JSON-LD @list to preserve order. 

Slots _may_ also declare a "shortcut" property, whose value is a URI, specifying the relationship the Slot defines between its linked Objects (via _slotof_) and its _contents_. For example, a Slot may declare it relates its linked Object is related to its Object reference contents via Building Topology Ontology's "hasElement" relation: 

[source,json]
----
{   "@id":"Bdskjasd/asdj",
    "@type":["Slot"],
    "slotof":"Bdskjasd",
    "shortcut":"http://w3id.org/bot#hasElement",
    "contents":[{
        "@id":"fooo"
}]
}
----

Linked data systems may then use this shortcut property to "unpack" the underlying RDF triple: 

[source,sparql]
----
SELECT DISTINCT ?object ?shortcut ?target WHERE {
  ?slot <http://ifc-ld.org#slotof> ?object .
  ?slot <http://ifc-ld.org#shortcut> ?shortcut .
  ?slot <http://ifc-ld.org#contents> ?target . 
}
----

Use of Slot shortcuts is optional.

NOTE: During conversion with P21 data, a Slot's "contents" @type maps to a known semantic type, like IfcRatioMeasure. Otherwise, a default XSD type is used. 


==== Objects

"Objects" are a Container for Slots, with each Slot encoding some qualifying aspect of the Object. Like Slots, Objects are addressed by URI. Objects typically capture any asset, real or imagined, stakeholders want to track across time and revisions. Because their state is the superposition of many Slots (each with its own provenance information), Objects do not not themselves declare provenance information like timestamp or ownership. 

Objects _should_ be grouped into one or more Packages, each of which captures the circumstances that changed the state of the Object (through the introduction of new Slots). An Object may be the _objectof_ more than one Package. 

Here is an example Object:
[source,json]
----
{   "@id":"Bdskjasd",
    "@type":["Object", "ifc5:product"],
    "objectof":"a-package",
    "slots":[{...}]
}
----

NOTE: For interoperability with IFC-STP, Objects correspond to P21 instances. 

==== Packages

Packages are Containers for Objects. Packages define some event - a project deliverable, point-to-point exchange, etc - that justified the modification or transaction of Objects and Slots. Because Packages describe events, they contain provenance information similar to Slots.

Here is an example Package:

[source,json]
----
{   "@id":"Bdskjasd",
    "@type":["Package"],
    "meta":{
        "who":"Acme Corp",
        "when":"2020-11-30T17:44:46"
    },
    "objects":[{...}]
}
----


=== Serializations

The IFC-LD data model is independent of its serialization. It it possible, for example, to use standard RDF encodings to serialize IFC-LD as XML, HTML, JSON, Turle, or N3. IFC-LD recommends JSON as its primary serialization format, because it allows the data to be parsed without external tools, and can be treated as JSON for systems without linked data support.

JSON's flexibility permits more than one JSON representation of the same IFC-LD data. For example, a collection of Packages, Objects, and Slots could be organized as a JSON array (suitable for streaming), or as a hierarchical JSON object (suitable for browser or lookup by ID). IFC-LD therefore supports several standard JSON serializations, each identified by its own https://en.wikipedia.org/wiki/Media_type[media type]. Where possible, these serializations strive to be losslessly interoperable. 

==== application/ifc.json+stream

The IFC-LD "Stream" format, identified by media type `application/ifc.json+stream`, captures all IFC-LD assets in a flat array. 
Here is a sample IFC-LD stream:

[source,json]
----
[
    {   "@id":"Bdskjasd",
    "@type":["Package"],
    "meta":{
        "who":"Acme Corp",
        "when":"2020-11-30T17:44:46"
    }
}, 

{   "@id":"Bdskjasd",
    "@type":["Object", "ifc5:product"],
    "objectof":"a-package"
}, 
{   "@id":"Bdskjasd/asdj",
    "@type":["Slot"],
    "slotof":"Bdskjasd",
    "shortcut":"http://w3id.org/bot#hasElement",
    "contents":[{
        "@id":"fooo"
}]
}
]
----

IFC-LD streams are useful for event-driven systems and one-at-a-time processing. They encourage the the exchange of "delta updates", wherein individual Slots, Objects, and Packages can be shared, instead of monolithic model files. 

==== application/ifc.json+pkg

The IFC-LD "Package" format, identified by media type `application/ifc.json+pkg`, captures IFC-LD assets as a nested hierarchy of Containers, where a root Package contains Objects, and Objects contain Slots. 

Here is a sample IFC-LD Package file:

[source,json]
----
[
    {   "@id":"Bdskjasd",
    "@type":["Package"],
    "meta":{
        "who":"Acme Corp",
        "when":"2020-11-30T17:44:46"
    }, 
    "objects":{
   "Bdskjasd":
   {"@id":"Bdskjasd",
    "@type":["Object", "ifc5:product"],
    "objectof":"a-package", 
    "slots":{}
    }
}, 
    ]
}
] 

----

The IFC-LD Package format is most useful for browsing the Objects of a single Package. Because Objects and Slots in this format are indexed by JSON keys, systems without linked data support can still traverse the network of linked objects by dereferencing the corresponding JSON keys. 

NOTE: For interoperability with IFC-STP, the IFC-LD Package format corresponds to a P21 instance population. 


==== Serialization Interoperability

`application/ifc.json+stream` and `application/ifc.json+pkg` are losslessly interoperable; a IFC-LD stream can be encoded in the package format and back again with no loss of information. The <<Proof-of-Concept Transformation Pipeline>> outlines a reference architecture for this transformation flow, with notes for future work. 

Future versions of the IFC-LD specification may introduce at least one JSON serializations that are derived from, but not losslessly convertible to, the stream or package formats. These serializations would be tailored to specific use cases (e.g., visualization) where small file size is the key objective. These 

== Reference

=== Community

Website: http://ifc-ld.org
Github: https://github.com/devonsparks/ifc-ld

=== Playground

NOTE: Coming soon. Once the pipeline reference implementation is complete, the intent is to deploy it with a small web frontend here so users can play with the various IFC-LD formats directly in their browser. 

=== FAQs

=== Why is asset addressability important? 

==== The format seems "busy". Aren't there a smaller, simpler JSON formats for IFC? 

==== How does IFC-LD compare to ifcOWL?

==== How does IFC-LD compare to other industry linked data ontologies?

=== Proof-of-Concept Transformation Pipeline

As of summer 2022, a proof-of-concept transformation pipeline demonstrating lossless interoperability between the P21, `application/ifc.json+stream`, `application/ifc.json+pkg` formats has been developed. The pipeline's design is unusual in that, outside of a P21 parser, all transformations are standard JSON-LD operations (compactions, flattenings, or frames); all data transformation is data-driven from JSON-LD definitions. 

image::img/pipeline.png[A diagram of the POC transformation pipeline, showing the forward transformation flow from P21 to IFC-LD stream and package formats.]

The POC pipeline spends the majority of its operating performing JSON-LD framing between the stream and package formats. For a production system, we recommend all compactions on incoming IFC-LD assets be done one-at-a-time (instead of on the whole stream, as is currently done), and that the JSON-LD reframing operation be replaced with an imperative equivalent that could operate on persistent storage. 

The intent is to release the POC transformation pipeline, along with several optimizations, before the end of 2022.


=== Industry Adoption Strategy

For IFC-LD to be successful, it is important it be easily integrated into industry practice. By supporting losslessly interoperability with P21, a IFC-LD reference implementation could immediately be put into practice. Once a suitable reference implementation has been developed, we recommend:

. It be containerized and made available for both public deployment (with rate and size limits) and private use. 
. Vendor import/export dialog boxes provide hooks to pass P21 data to or from a deployment of the reference implementation, circumventing the need for vendor tools to build IFC-LD support natively.
. Over time, the community work to stablize the reference implementation so it can be easily leveraged across vendor products and tools. 

=== Looking Forward: ECS and Compositional Modeling

There's beeen a growing recognition with the industry to support https://en.wikipedia.org/wiki/Composition_over_inheritance["composition modeling"] of built asset data. Property Sets within the existing IFC specification support one flavor of this, in that multiple parties can attach different pieces of data to the same asset without prior coordination. How far can this model be taken and how can IFC-LD help?

IFC-LD provides support for compositional modeling at its core. Objects are identified by their UIR. 
=== Schema Validation

=== JSON-LD @contexts

=== JSON Schema



=== Acknowledgements

Created by Devon Sparks (devonsparks.com) with input from members of the BuildingSmart community. Thanks to the https://github.com/stepcode/stepcode[stepcode] team for collaboration on supporting pull requests for the STEP P21 parser and answering questions about the design of the STEP EXPRESS parser. 